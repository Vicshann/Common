
//------------------------------------------------------------------------------------------------------------
constexpr static _finline DWORD CTL_CODE(DWORD DeviceType, DWORD Function, DWORD Method, DWORD Access) { return ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method); }
constexpr static _finline DWORD DEVICE_TYPE_FROM_CTL_CODE(DWORD ctrlCode) { return (((DWORD)(ctrlCode & 0xffff0000)) >> 16); }   // Macro to extract device type out of the device io control code
constexpr static _finline DWORD METHOD_FROM_CTL_CODE(DWORD ctrlCode) { return ((DWORD)(ctrlCode & 3)); }  // Macro to extract buffering method out of the device io control code

enum EIOMETHD: DWORD
{
 METHOD_BUFFERED   = 0,
 METHOD_IN_DIRECT  = 1,
 METHOD_OUT_DIRECT = 2,
 METHOD_NEITHER    = 3,
};

enum EFACCESS: DWORD
{
 FILE_ANY_ACCESS      = 0,
 FILE_SPECIAL_ACCESS  = FILE_ANY_ACCESS,
 FILE_READ_ACCESS     = FILE_READ_DATA,    // file & pipe
 FILE_WRITE_ACCESS    = FILE_WRITE_DATA,   // file & pipe
};

enum EFDEVS: DWORD
{
 FILE_DEVICE_BEEP                = 0x00000001,
 FILE_DEVICE_CD_ROM              = 0x00000002,
 FILE_DEVICE_CD_ROM_FILE_SYSTEM  = 0x00000003,
 FILE_DEVICE_CONTROLLER          = 0x00000004,
 FILE_DEVICE_DATALINK            = 0x00000005,
 FILE_DEVICE_DFS                 = 0x00000006,
 FILE_DEVICE_DISK                = 0x00000007,
 FILE_DEVICE_DISK_FILE_SYSTEM    = 0x00000008,
 FILE_DEVICE_FILE_SYSTEM         = 0x00000009,
 FILE_DEVICE_INPORT_PORT         = 0x0000000a,
 FILE_DEVICE_KEYBOARD            = 0x0000000b,
 FILE_DEVICE_MAILSLOT            = 0x0000000c,
 FILE_DEVICE_MIDI_IN             = 0x0000000d,
 FILE_DEVICE_MIDI_OUT            = 0x0000000e,
 FILE_DEVICE_MOUSE               = 0x0000000f,
 FILE_DEVICE_MULTI_UNC_PROVIDER  = 0x00000010,
 FILE_DEVICE_NAMED_PIPE          = 0x00000011,
 FILE_DEVICE_NETWORK             = 0x00000012,
 FILE_DEVICE_NETWORK_BROWSER     = 0x00000013,
 FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014,
 FILE_DEVICE_NULL                = 0x00000015,
 FILE_DEVICE_PARALLEL_PORT       = 0x00000016,
 FILE_DEVICE_PHYSICAL_NETCARD    = 0x00000017,
 FILE_DEVICE_PRINTER             = 0x00000018,
 FILE_DEVICE_SCANNER             = 0x00000019,
 FILE_DEVICE_SERIAL_MOUSE_PORT   = 0x0000001a,
 FILE_DEVICE_SERIAL_PORT         = 0x0000001b,
 FILE_DEVICE_SCREEN              = 0x0000001c,
 FILE_DEVICE_SOUND               = 0x0000001d,
 FILE_DEVICE_STREAMS             = 0x0000001e,
 FILE_DEVICE_TAPE                = 0x0000001f,
 FILE_DEVICE_TAPE_FILE_SYSTEM    = 0x00000020,
 FILE_DEVICE_TRANSPORT           = 0x00000021,
 FILE_DEVICE_UNKNOWN             = 0x00000022,
 FILE_DEVICE_VIDEO               = 0x00000023,
 FILE_DEVICE_VIRTUAL_DISK        = 0x00000024,
 FILE_DEVICE_WAVE_IN             = 0x00000025,
 FILE_DEVICE_WAVE_OUT            = 0x00000026,
 FILE_DEVICE_8042_PORT           = 0x00000027,
 FILE_DEVICE_NETWORK_REDIRECTOR  = 0x00000028,
 FILE_DEVICE_BATTERY             = 0x00000029,
 FILE_DEVICE_BUS_EXTENDER        = 0x0000002a,
 FILE_DEVICE_MODEM               = 0x0000002b,
 FILE_DEVICE_VDM                 = 0x0000002c,
 FILE_DEVICE_MASS_STORAGE        = 0x0000002d,
 FILE_DEVICE_SMB                 = 0x0000002e,
 FILE_DEVICE_KS                  = 0x0000002f,
 FILE_DEVICE_CHANGER             = 0x00000030,
 FILE_DEVICE_SMARTCARD           = 0x00000031,
 FILE_DEVICE_ACPI                = 0x00000032,
 FILE_DEVICE_DVD                 = 0x00000033,
 FILE_DEVICE_FULLSCREEN_VIDEO    = 0x00000034,
 FILE_DEVICE_DFS_FILE_SYSTEM     = 0x00000035,
 FILE_DEVICE_DFS_VOLUME          = 0x00000036,
 FILE_DEVICE_SERENUM             = 0x00000037,
 FILE_DEVICE_TERMSRV             = 0x00000038,
 FILE_DEVICE_KSEC                = 0x00000039,
 FILE_DEVICE_FIPS                = 0x0000003A,
 FILE_DEVICE_INFINIBAND          = 0x0000003B,
 FILE_DEVICE_VMBUS               = 0x0000003E,
 FILE_DEVICE_CRYPT_PROVIDER      = 0x0000003F,
 FILE_DEVICE_WPD                 = 0x00000040,
 FILE_DEVICE_BLUETOOTH           = 0x00000041,
 FILE_DEVICE_MT_COMPOSITE        = 0x00000042,
 FILE_DEVICE_MT_TRANSPORT        = 0x00000043,
 FILE_DEVICE_BIOMETRIC		     = 0x00000044,
 FILE_DEVICE_PMI                 = 0x00000045,
};

//enum EIOCTL: DWORD      // winioctl.h        // Dumb C++ forbids to see the CTL_CODE function in this enum. At least it can 'see' it in direct members because the NNTDLL class is a template
//{
// IoControlCode values for disk devices
SCVR DWORD IOCTL_DISK_BASE                 = FILE_DEVICE_DISK;
SCVR DWORD IOCTL_DISK_GET_DRIVE_GEOMETRY   = CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_GET_PARTITION_INFO   = CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_LAYOUT     = CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_REQUEST_DATA         = CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_IS_WRITABLE          = CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_DISK_CONTROLLER_NUMBER    = CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS);

// IOCTL support for SMART drive fault prediction
SCVR DWORD SMART_GET_VERSION               = CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD SMART_SEND_DRIVE_COMMAND        = CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD SMART_RCV_DRIVE_DATA            = CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

// New IOCTLs for GUID Partition tabled disks
SCVR DWORD IOCTL_DISK_GET_PARTITION_INFO_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_SET_PARTITION_INFO_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_LAYOUT_EX      = CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_SET_DRIVE_LAYOUT_EX      = CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_CREATE_DISK              = CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_GET_LENGTH_INFO          = CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_GEOMETRY_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS);

// The following device control codes are common for all class drivers.
SCVR DWORD IOCTL_DISK_CHECK_VERIFY     = CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_MEDIA_REMOVAL    = CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_EJECT_MEDIA      = CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_LOAD_MEDIA       = CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_RESERVE          = CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_RELEASE          = CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_FIND_NEW_DEVICES = CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_MEDIA_TYPES  = CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_STORAGE_BASE = FILE_DEVICE_MASS_STORAGE;
// The following device control codes are common for all class drivers. They should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE common codes

SCVR DWORD IOCTL_STORAGE_CHECK_VERIFY            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_CHECK_VERIFY2           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_MEDIA_REMOVAL           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_EJECT_MEDIA             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_LOAD_MEDIA              = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_LOAD_MEDIA2             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_RESERVE                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_RELEASE                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_FIND_NEW_DEVICES        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS);

SCVR DWORD IOCTL_STORAGE_EJECTION_CONTROL        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_MCN_CONTROL             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_STORAGE_GET_MEDIA_TYPES         = CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_MEDIA_TYPES_EX      = CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_HOTPLUG_INFO        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_SET_HOTPLUG_INFO        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_STORAGE_RESET_BUS               = CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_RESET_DEVICE            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_BREAK_RESERVATION       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_PERSISTENT_RESERVE_IN   = CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_PERSISTENT_RESERVE_OUT  = CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_STORAGE_GET_DEVICE_NUMBER       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_PREDICT_FAILURE         = CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS);


SCVR DWORD IOCTL_VOLUME_BASE                     = 0x00000056; 

// IOCTL to obtain the physical location of the specified volume on one or more disks.
SCVR DWORD IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS  = CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS);

// IOCTLs to transition the specified volume between r/w and non r/w modes.
SCVR DWORD IOCTL_VOLUME_ONLINE                   = CTL_CODE(IOCTL_VOLUME_BASE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_VOLUME_OFFLINE                  = CTL_CODE(IOCTL_VOLUME_BASE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_VOLUME_GET_GPT_ATTRIBUTES       = CTL_CODE(IOCTL_VOLUME_BASE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS);

// The following is a list of the native file system fsctls followed by additional network file system fsctls.  Some values have been decommissioned.
SCVR DWORD FSCTL_LOCK_VOLUME               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_UNLOCK_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DISMOUNT_VOLUME           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS);
                               
SCVR DWORD FSCTL_IS_VOLUME_MOUNTED         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_IS_PATHNAME_VALID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS); // PATHNAME_BUFFER,
SCVR DWORD FSCTL_MARK_VOLUME_DIRTY         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                
SCVR DWORD FSCTL_QUERY_RETRIEVAL_POINTERS  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_GET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA);
                             
SCVR DWORD FSCTL_SET_BOOTLOADER_ACCESSED   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_OPLOCK_BREAK_ACK_NO_2     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_INVALIDATE_VOLUMES        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_QUERY_FAT_BPB             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS); // FSCTL_QUERY_FAT_BPB_BUFFER
SCVR DWORD FSCTL_REQUEST_FILTER_OPLOCK     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_FILESYSTEM_GET_STATISTICS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILESYSTEM_STATISTICS
                              
SCVR DWORD FSCTL_GET_NTFS_VOLUME_DATA      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS); // NTFS_VOLUME_DATA_BUFFER
SCVR DWORD FSCTL_GET_NTFS_FILE_RECORD      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS); // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
SCVR DWORD FSCTL_GET_VOLUME_BITMAP         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS); // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
SCVR DWORD FSCTL_GET_RETRIEVAL_POINTERS    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS); // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
SCVR DWORD FSCTL_MOVE_FILE                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // MOVE_FILE_DATA,
SCVR DWORD FSCTL_IS_VOLUME_DIRTY           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS);
                              
SCVR DWORD FSCTL_FIND_FILES_BY_SID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS);
                               
SCVR DWORD FSCTL_SET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_GET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_DELETE_OBJECT_ID          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // REPARSE_DATA_BUFFER,
SCVR DWORD FSCTL_GET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS); // REPARSE_DATA_BUFFER
SCVR DWORD FSCTL_DELETE_REPARSE_POINT      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // REPARSE_DATA_BUFFER,
SCVR DWORD FSCTL_ENUM_USN_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS); // MFT_ENUM_DATA,
SCVR DWORD FSCTL_SECURITY_ID_CHECK         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA);  // BULK_SECURITY_TEST_DATA,
SCVR DWORD FSCTL_READ_USN_JOURNAL          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS); // READ_USN_JOURNAL_DATA, USN
SCVR DWORD FSCTL_SET_OBJECT_ID_EXTENDED    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_CREATE_OR_GET_OBJECT_ID   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_SET_SPARSE                = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_ZERO_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA); // FILE_ZERO_DATA_INFORMATION,
SCVR DWORD FSCTL_QUERY_ALLOCATED_RANGES    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA);  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
SCVR DWORD FSCTL_ENABLE_UPGRADE            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA);

SCVR DWORD FSCTL_SET_ENCRYPTION            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS); // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
SCVR DWORD FSCTL_ENCRYPTION_FSCTL_IO       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_WRITE_RAW_ENCRYPTED       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS); // ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
SCVR DWORD FSCTL_READ_RAW_ENCRYPTED        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS); // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
SCVR DWORD FSCTL_CREATE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS); // CREATE_USN_JOURNAL_DATA,
SCVR DWORD FSCTL_READ_FILE_USN_DATA        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS); // Read the Usn Record for a file
SCVR DWORD FSCTL_WRITE_USN_CLOSE_RECORD    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS); // Generate Close Usn Record
SCVR DWORD FSCTL_EXTEND_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_QUERY_USN_JOURNAL         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DELETE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_MARK_HANDLE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SIS_COPYFILE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SIS_LINK_FILES            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA);
                               
SCVR DWORD FSCTL_RECALL_FILE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_READ_FROM_PLEX            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA);
SCVR DWORD FSCTL_FILE_PREFETCH             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // FILE_PREFETCH

SCVR DWORD FSCTL_MAKE_MEDIA_COMPATIBLE         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA); // UDFS R/W
SCVR DWORD FSCTL_SET_DEFECT_MANAGEMENT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA); // UDFS R/W
SCVR DWORD FSCTL_QUERY_SPARING_INFO            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS); // UDFS R/W
SCVR DWORD FSCTL_QUERY_ON_DISK_VOLUME_INFO     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS); // C/UDFS
SCVR DWORD FSCTL_SET_VOLUME_COMPRESSION_STATE  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // VOLUME_COMPRESSION_STATE
                               
SCVR DWORD FSCTL_SET_ZERO_ON_DEALLOCATION      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_GET_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_WAIT_FOR_REPAIR               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD FSCTL_INITIATE_REPAIR               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_CSC_INTERNAL                  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS); // CSC internal implementation
SCVR DWORD FSCTL_SHRINK_VOLUME                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // SHRINK_VOLUME_INFORMATION
SCVR DWORD FSCTL_SET_SHORT_NAME_BEHAVIOR       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DFSR_SET_GHOST_HANDLE_STATE   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                    
SCVR DWORD FSCTL_QUERY_PAGEFILE_ENCRYPTION     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_RESET_VOLUME_ALLOCATION_HINTS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SD_GLOBAL_CHANGE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS); // Update NTFS Security Descriptors
SCVR DWORD FSCTL_LOOKUP_STREAM_FROM_CLUSTER    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_FILE_TYPE_NOTIFICATION        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                    
SCVR DWORD FSCTL_GET_BOOT_AREA_INFO            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS);  // BOOT_AREA_INFO
SCVR DWORD FSCTL_GET_RETRIEVAL_POINTER_BASE    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS);  // RETRIEVAL_POINTER_BASE
SCVR DWORD FSCTL_SET_PERSISTENT_VOLUME_STATE   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS);  // FILE_FS_PERSISTENT_VOLUME_INFORMATION
SCVR DWORD FSCTL_QUERY_PERSISTENT_VOLUME_STATE = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS);  // FILE_FS_PERSISTENT_VOLUME_INFORMATION


//};

enum MEDIA_TYPE 
{
 Unknown,                // Format is unknown
 F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
 F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
 F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
 F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
 F3_720_512,             // 3.5",  720KB,  512 bytes/sector
 F5_360_512,             // 5.25", 360KB,  512 bytes/sector
 F5_320_512,             // 5.25", 320KB,  512 bytes/sector
 F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
 F5_180_512,             // 5.25", 180KB,  512 bytes/sector
 F5_160_512,             // 5.25", 160KB,  512 bytes/sector
 RemovableMedia,         // Removable media other than floppy
 FixedMedia,             // Fixed hard disk media
 F3_120M_512,            // 3.5", 120M Floppy
 F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
 F5_640_512,             // 5.25",  640KB,  512 bytes/sector
 F5_720_512,             // 5.25",  720KB,  512 bytes/sector
 F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
 F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
 F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
 F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
 F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
 F8_256_128,             // 8",     256KB,  128 bytes/sector
 F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
 F3_240M_512,            // 3.5",   240Mb Floppy (HiFD)
 F3_32M_512              // 3.5",   32Mb Floppy
};

enum PARTITION_STYLE 
{
 PARTITION_STYLE_MBR,
 PARTITION_STYLE_GPT,
 PARTITION_STYLE_RAW
};

// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES request.
struct DISK_GEOMETRY 
{
 LARGE_INTEGER Cylinders;
 MEDIA_TYPE MediaType;
 DWORD TracksPerCylinder;
 DWORD SectorsPerTrack;
 DWORD BytesPerSector;
};

struct DISK_GEOMETRY_EX      // IOCTL_DISK_GET_DRIVE_GEOMETRY_EX IOCTL
{
  DISK_GEOMETRY Geometry;
  LARGE_INTEGER DiskSize;
  BYTE          Data[1];
};

// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
struct PARTITION_INFORMATION 
{
 LARGE_INTEGER StartingOffset;
 LARGE_INTEGER PartitionLength;
 DWORD HiddenSectors;
 DWORD PartitionNumber;
 BYTE  PartitionType;
 BOOLEAN BootIndicator;
 BOOLEAN RecognizedPartition;
 BOOLEAN RewritePartition;
};

// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
struct DRIVE_LAYOUT_INFORMATION 
{
  DWORD PartitionCount;
  DWORD Signature;
  PARTITION_INFORMATION PartitionEntry[1];
};

// The following structure defines information in a GPT partition that is not common to both GPT and MBR partitions.
struct PARTITION_INFORMATION_GPT 
{
 GUID  PartitionType;                 // Partition type. See table 16-3.
 GUID  PartitionId;                   // Unique GUID for this partition.
 QWORD Attributes;                 // See table 16-4.
 WCHAR Name [36];                    // Partition Name in Unicode.
};

// The following structure defines information in an MBR partition that is not common to both GPT and MBR partitions.
struct PARTITION_INFORMATION_MBR 
{
 BYTE  PartitionType;
 BOOLEAN BootIndicator;
 BOOLEAN RecognizedPartition;
 DWORD HiddenSectors;
};

// GPT specific drive layout information.
struct DRIVE_LAYOUT_INFORMATION_GPT 
{
 GUID DiskId;
 LARGE_INTEGER StartingUsableOffset;
 LARGE_INTEGER UsableLength;
 DWORD MaxPartitionCount;
};

// MBR specific drive layout information.
struct DRIVE_LAYOUT_INFORMATION_MBR 
{
 DWORD Signature;
};

// The structure GET_LENGTH_INFORMATION is used with the ioctl IOCTL_DISK_GET_LENGTH_INFO to obtain the length, in bytes, of the disk, partition, or volume.
struct GET_LENGTH_INFORMATION 
{
 LARGE_INTEGER Length;
};

// The PARTITION_INFORMATION_EX structure is used with the IOCTL_DISK_GET_DRIVE_LAYOUT_EX, IOCTL_DISK_SET_DRIVE_LAYOUT_EX, IOCTL_DISK_GET_PARTITION_INFO_EX and IOCTL_DISK_GET_PARTITION_INFO_EX calls.
struct PARTITION_INFORMATION_EX 
{
  PARTITION_STYLE PartitionStyle;
  LARGE_INTEGER StartingOffset;
  LARGE_INTEGER PartitionLength;
  DWORD   PartitionNumber;
  BOOLEAN RewritePartition;
  union {
      PARTITION_INFORMATION_MBR Mbr;
      PARTITION_INFORMATION_GPT Gpt;
  } DUMMYUNIONNAME;
};

// The structure DRIVE_LAYOUT_INFORMATION_EX is used with the IOCTL_SET_DRIVE_LAYOUT_EX and IOCTL_GET_DRIVE_LAYOUT_EX calls.
struct DRIVE_LAYOUT_INFORMATION_EX 
{
 DWORD PartitionStyle;
 DWORD PartitionCount;
 union {
     DRIVE_LAYOUT_INFORMATION_MBR Mbr;
     DRIVE_LAYOUT_INFORMATION_GPT Gpt;
 } DUMMYUNIONNAME;
 PARTITION_INFORMATION_EX PartitionEntry[1];
};

// The DISK_GEOMETRY_EX structure is returned on issuing an IOCTL_DISK_GET_DRIVE_GEOMETRY_EX ioctl.
enum DETECTION_TYPE 
{
 DetectNone,
 DetectInt13,
 DetectExInt13
};

struct DISK_INT13_INFO 
{
 WORD   DriveSelect;
 DWORD  MaxCylinders;
 WORD   SectorsPerTrack;
 WORD   MaxHeads;
 WORD   NumberDrives;
};

struct DISK_EX_INT13_INFO 
{
 WORD   ExBufferSize;
 WORD   ExFlags;
 DWORD  ExCylinders;
 DWORD  ExHeads;
 DWORD  ExSectorsPerTrack;
 QWORD  ExSectorsPerDrive;
 WORD   ExSectorSize;
 WORD   ExReserved;
};

// The values in the STORAGE_DEVICE_NUMBER structure are guaranteed to remain unchanged until the system is rebooted.  They are not guaranteed to be persistant across boots.
struct STORAGE_DEVICE_NUMBER 
{
 DWORD  DeviceType;        // The FILE_DEVICE_XXX type for this device.  // DEVICE_TYPE
 DWORD  DeviceNumber;      // The number of this device
 DWORD  PartitionNumber;   // If the device is partitionable, the partition number of the device. Otherwise -1
};


struct DISK_EXTENT   // IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
{
 DWORD DiskNumber;     // Specifies the storage device number of the disk on which this extent resides.
 LARGE_INTEGER StartingOffset;    // Specifies the offset and length of this extent relative to the beginning of the disk.
 LARGE_INTEGER ExtentLength;
};

template<int N> struct VOLUME_DISK_EXTENTS 
{
 DWORD NumberOfDiskExtents;    // Specifies one or more contiguous range of sectors that make up this volume.
 DISK_EXTENT Extents[N];
};
//------------------------------------------------------------------------------------------------------------
//============================================================================================================
// A clear operation is valid only on files that no longer have any sparse regions. 
//Performing a clear operation on a file with sparse regions can have unpredictable results. 
//You can determine whether there are any sparse regions in a file by using the FSCTL_QUERY_ALLOCATED_RANGES control code.
struct FILE_SET_SPARSE_BUFFER    
{
 BOOLEAN SetSparse;
};

struct FILE_ZERO_DATA_INFORMATION    // Structure for FSCTL_SET_ZERO_DATA
{
 LARGE_INTEGER FileOffset;
 LARGE_INTEGER BeyondFinalZero;
};
//------------------------------------------------------------------------------------------------------------
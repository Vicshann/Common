
# --------------- COMPILER CONFIGURATION ---------------------------------
-v
-x c++
-std=c++23
#-std=gnu++2b
-target x86_64-windows-gnu-gcc
#-mfloat-abi=none  // No effect, NEON is still used
#-target-feature +crc
# -ffreestanding -triple aarch64-none-eabi -target-feature +v9.4a -target-feature +crc -target-feature +rand -target-feature +d128
#-fuse-ld=ld
-fuse-ld=lld
# Adding this makes the module relocatable.
# It gets rid of linker version string but adds a bunch of reloc sections
#-r
# Remove all symbol table and relocation information from the executable
# Strips all garbage like source file names and function names
#-s
# Produce debugging information for use by GDB. This means to use the most expressive format available
#  (DWARF, stabs, or the native format if neither of those are supported), including GDB extensions if at all possible.
#-ggdb
#-ggdb2
# Produce debugging information in the operating systemâ€™s native format (stabs, COFF, XCOFF, or DWARF). GDB can work with this debugging information.
-g3
# Produce debugging information in DWARF format (if that is supported). The value of version may be either 2, 3, 4 or 5; the default version for most targets is 4.
-gdwarf-4
# ???
#Og
# Not everything is moved to a separate file with 'gsplit-dwarf'
# For debugging with lldb it is possible to move all debug sections to a separate PE file:
#    llvm-objcopy --only-keep-debug appname.exe appname.dbg
#    llvm-objcopy --strip-all appname.exe
#    llvm-objcopy --add-gnu-debuglink=appname.dbg appname.exe
#-gsplit-dwarf
#-fstandalone-debug
# NOTE: Os creates some calls to functioons like memcpy
-O0
#-fno-vectorize
#-fno-slp-vectorize
#-fno-unroll-loops
# This register contains UBOOT context
#-ffixed-x18
# Old UBOOT uses different register (Requires modified CLANG)
#-ffixed-r9
#-Wl,-no-dynamic-linker
# No effect?
#-gsplit-dwarf
# No effect?
#-fstandalone-debug
#-dead-strip
# Remove unused sections. Like those with unused external linkage functions (-ffunction-sections)
#-Wl,-gc-sections
# Generates a separate ELF section for each (external linkage) function in the source file
#-ffunction-sections
# Enables all bad things wig EP disappearance and orphaned functions if there is a function with __attribute__((used))
#-flto
# Will this be cause of dynamic symbols table creation?
-fPIE
#-fPIC
-fno-rtti
-nostdlib
-nostdlib++
-nostdlibinc
-nostartfiles
#-nobuiltininc
-nostdinc
-nostdinc++
# No need for __cxa_guard_acquire and __cxa_guard_release if a function contains stativ variables
-fno-threadsafe-statics
-fno-stack-protector
# ('-fno-builtin') Same as '-mkernel'? A hint that the standard library may not exist (functions with standard names may do something else)
# For now it is causing misalignmeng BUG (An it enforces NEON on ARM (With wrong alignment))
# What exactly it is affecting?
-ffreestanding
# Looks like this fixes the alignment issue  # What about keping everything properly aligned for perfomance reasons?
# Causes calls to memcpy!!!
#-mno-unaligned-access
# indicates that the compiler should not assume that unaligned memory references are handled by the system
# Same as no-unaligned-access?  # Just a workaround, as a hardware misaligned access support
# Causes calls to memcpy!!!
-mstrict-align
# Does nothing! Still requires external memcpy which is never inlined!
#-mllvm --disable-memcpy-idiom
# Not accepted
#-mllvm -mattr=-neon
-fno-asynchronous-unwind-tables
-fno-unwind-tables
-fno-exceptions
-ffast-math
#-foptimize-sibling-calls
# ????
#-fno-ident
# Unknown
#-no-define-common
# Will not affect extern "C"
# Not working for ARM (Looks like it is MACH-O only)? Had to use -s
-fvisibility=hidden
# Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.
#-mcmodel=tiny
# tail call optimization can help to make the code nondecompilable (Should be enabled by default starting from O2)
-foptimize-sibling-calls
-mbranch-protection=none
# Required for intrinsics like '__readgsqword' (TODO: Use ASM instead)
-fms-extensions
# Disables insertion for '__chkstk_ms' (Don`t forget to set allocated stack size large enough)
-mno-stack-arg-probe
#-mstack-probe-size=100000
-Weverything
-Wno-c++98-compat
-Wno-c++98-compat-pedantic
-Wno-unused-function
-Wno-old-style-cast
-Wno-unneeded-internal-declaration
-Wno-zero-length-array
-Wno-c99-extensions
-Wno-vla-extension
-Wno-c++20-compat
-Wno-reserved-identifier
-Wno-missing-prototypes
-Wno-cast-qual
-Wno-char-subscripts
-Wno-unsafe-buffer-usage
-Wno-implicit-fallthrough
-Wno-gnu-anonymous-struct
-Wno-gnu-include-next
-Wno-nested-anon-types
-Wno-unused-template
-Wno-date-time
-Wno-alloca
-Wno-psabi
# Useful for debugging of system struct porting
-Wno-padded
# Useful for debugging of unaligned memory access
-Wno-cast-align

#-shared
# Add all symbols, even unused ones to dynamic symbol table
#-rodynamic
# Disable lazy loading completely:
# -fPIC -no-pl
# Linker: -z now -z retro
# Do not write compiler version string to object files (Works with Clang too?)
#-fno-ident
# ??? Otherwise the compiler can assume that for example memcpy() does exactly what it is supposed to and could be replaced with an inlined equivalent
#-no-builtin
#-disable-simplify-libcalls
#-fpack-struct=16
#--help-hidden

# Current dir of these scrips is the project`s root
#-I ./COMPILER/include/
#-I ./FRAMEWORK/Platforms/
#-I ./COMMON/FRAMEWORK/Platforms/

-DDEBUG
-DPLT_WIN_USR
# --------------- LINKER CONFIGURATION ---------------------------------
# Same module loading behaviour is used as on Linux. A binary can be executed directly or loaded dynamically 
# Do not mark the PE as DLL or it won`t be directly executable
# Always mark the PE as relocatable (But without relocs, just build as PIC) [/FIXED:NO] [/DYNAMICBASE] ?
# /SUBSYSTEM:CONSOLE is default but useful only for executables that run not from console and require some input
#
#-Xlinker -e___ASysMain
-Wl, -eAppEntryPoint
# Console, Windows, Native, EFI-Application, EFI-Boot-Service-Driver, EFI-ROM, EFI-Runtime-Driver
-Wl,-subsystem,console:5.1
#-Wl,-no-dynamic-linker
-Wl,-Map,BUILD/output.map
# LTO may somehow made code a little bigger by adding some NOPS in the code (Fixed by -Os)
# When LTO meets a function marked as __attribute__((used)):
# Starting from lto-O2 it may remove main EP, messing up input arguments and making couple of orphaqned functions
# With lto-O1 it will keep EP but leave some orphaned functions above it(which is bad when linking to raw binary)
#-Wl,--lto-O3
# No effect! Debug tag and source file names are still kept
# Overrides -s option and other garbage returns
#-Wl,-strip-debug
# Same as -s option of the compiler
#-Wl,--strip-all
# No effect ; GNU linker mode only on ELF only
#-Wl,--no-export-dynamic
# This will allow all dynsym sections to be removed (config->hasDynSymTab: false)
# Linker uses PIE flag mostly for PLT thunks which is not required anyway
# What about generated code?
#-Wl,--no-pie
# Remove unused sections (Keeps .comment)
#-Wl,-gc-sections
# Then what meaning of '--format=binary' which makes the linker to lose entry point?
#-Wl,--oformat=binary
# LLD tries to parse it as something else
#-Xlinker -dT COMPILE/Format.ld
# Current dir is project dir
#-Wl,-T,COMPILE/Format.ld
# No default linkeer script IN LLD
#-Wl,--verbose
# ???
#-Wl,-N
# How to prevent Clang from passing --eh-frame-hdr to LLD?
#-Wl,--no-eh-frame-hdr
# Useful
#-Wl,--print-map
# Another way of passing flags to linker ?
# Why by default was 64k? ; In case some ARM may be configured to use 64K pages, especially AArch64? ; Kernel will not load the image otherwise
# https://reviews.llvm.org/D77330
# What about PIC and page-relative data access(ADRP)?  ; https://stackoverflow.com/questions/41906688/what-are-the-semantics-of-adrp-and-adrl-instructions-in-arm-assembly
#-z max-page-size=0x1000
# -------------------- SOURCE FILES ----------------------------------

